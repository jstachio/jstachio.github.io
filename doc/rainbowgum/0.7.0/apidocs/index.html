<!DOCTYPE HTML>
<html lang>
<head>
<!-- Generated by javadoc (21) -->
<title>Overview (rainbowgum API 0.7.0)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="module index">
<meta name="generator" content="javadoc/ModuleIndexWriter">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="jstachio.css" title="Style">
<link rel="stylesheet" type="text/css" href="script-dir/jquery-ui.min.css" title="Style">
<script type="text/javascript" src="script.js"></script>
<script type="text/javascript" src="script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="script-dir/jquery-ui.min.js"></script>
</head>
<body class="module-index-page">
<script type="text/javascript">var pathtoroot = "./";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>                 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/properties.min.js"></script>                 <script>hljs.highlightAll();</script></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li class="nav-bar-cell1-rev">Overview</li>
<li>Module</li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html#overview">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list"></div>
<div class="nav-list-search"><a href="search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<div class="header">
<nav class="js-toc"></nav>
<h1 class="title">rainbowgum API 0.7.0</h1>
</div>
<div class="block"><h1 id="user-guide-heading" class="overview">User Guide</h1>

<strong>
Rainbow Gum: JDK 21+ SLF4J logging implementation
</strong>
<p>
<em>
Fast, modular, GraalVM native friendly and easy to use.
</em>
</p>

<h2 id="contents-heading" class="toc-title">Contents</h2>

<div class="js-toc-content">

<h2 id="gettingstarted">Getting Started</h2>


First step is to add <a href="#installation">Rainbow Gum as a dependency</a>. 
<p>
Second if you are not familiar with logging in the Java ecosystem please refer to
the excellent <a href="https://www.slf4j.org/manual.html">Logging facade SLF4J</a> documentation
particularly the <a href="https://www.slf4j.org/apidocs-2.1.0/org/slf4j/Logger.html">logger API</a>
and what logging Levels are. Logging levels are and how dotted logger names inherit levels is covered in
 the JDKs logging facade <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/System.Logger.Level.html" title="class or interface in java.lang" class="external-link"><code>System.Logger.Level</code></a> as well as 
 <a href="https://logback.qos.ch/manual/architecture.html#effectiveLevel">Logback effective level</a>
 which Rainbow Gum follows.

</p>
The third step is to configure. Most configuration is just configuring logger names to levels, output, and formatting. 
We will cover the major ways to do this in the following sub sections.

<h3 id="simple_spring_boot">Using Spring Boot</h3>

If using Spring Boot see <a href="#spring_boot">Rainbow Spring Boot Integration section</a>.

<h3 id="simple_example">Using System properties</h3>

Assuming we have <a href="#installation">installed RainbowGum as a dependency</a> a simple configuration example using System Properties is below:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code>  java \
  -Dlogging.appender.console.encoder=pattern \
  -Dlogging.encoder.console.pattern="[%thread] %-5level %logger{15} - %msg%n" \
  -Dlogging.level.com.myapp=DEBUG \
  myapp.jar
</code></pre>
</div>


What happens with the above is Rainbow Gum will load its default Rainbow Gum via the service loader and use the properties to configure
its builders. Unfortunately System properties on the command line can be rather tedious but luckily you
can plugin in your own properties system easily.

<h3 id="simple_example_builder">Using RainbowGum Builders</h3>

For organizations that have many projects it is recommended to use the programmatic builder approach and make a standardized jar (module)
shared between all your projects so that logging configuration is consistent.

Assuming we have <a href="#installation">installed RainbowGum as a dependency</a> a simple configuration example using
Java directly and the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/ServiceLoader.html" title="class or interface in java.util" class="external-link"><code>ServiceLoader</code></a> is below. 

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">public class GettingStartedExample implements RainbowGumProvider {

	@Override
	public Optional&lt;RainbowGum&gt; provide(LogConfig config) {

		return RainbowGum.builder(config) //
			.route(r -&gt; {
				r.level(Level.DEBUG, "com.myapp");
				r.appender("console", a -&gt; {
					a.encoder(new PatternEncoderBuilder("console")
						// We use the pattern encoder which follows logback pattern
						// syntax.
						.pattern("[%thread] %-5level %logger{15} - %msg%n")
						// We use properties to override the above pattern if set.
						.fromProperties(config.properties())
						.build());
				});
			}) //
			.optional();
	}

}
</code></pre>
</div>


<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/spi/RainbowGumServiceProvider.html" title="interface in io.jstach.rainbowgum.spi"><code>RainbowGumServiceProvider</code></a> has additional documentation on how to register
a service loader aware jar.

<h2 id="description">Description</h2>

Rainbow Gum is a JDK 21+ opinionated SLF4J implementation that aims to be easier to use
while leveraging newer JDK technology.

Rainbow Gum unlike Logback or Log4J (2) does not offer as much flexibility but is simpler
and has less overhead.

The <a href="https://github.com/jstachio/rainbowgum">readme in the Rainbow Gum project</a> 
discusses more extensively on the opinionated design and philosophy.


<h2 id="project_information">Project Information</h2>

<dl class="notes">
  <dt>Source Control</dt>
  <dd><a href="https://github.com/jstachio/rainbowgum">https://github.com/jstachio/rainbowgum</a></dd>
  <dt>Team</dt>
  <dd>
    <ul>
      <li><a href="https://github.com/agentgt">Adam Gent (agentgt)</a> - lead</li>
    </ul>
  </dd>
  <dt>Issues</dt>
  <dd><a href="https://github.com/jstachio/jstachio/issues">https://github.com/jstachio/rainbowgum/issues</a></dd>
  <dt>Community</dt>
  <dd><a href="https://github.com/jstachio/jstachio/discussions">https://github.com/jstachio/rainbowgum/discussions</a></dd>
  <dt>User Guide</dt>
  <dd>
    <a href="index.html">This document</a>
  </dd>
  <dt>Javadoc</dt>
  <dd>
    <a href="#all-modules-table">This document (modules listing at bottom)</a>
  </dd>
</dl>

The project follows <a href="https://semver.org/">semantic versioning</a>.

<h3 id="requirements">Requirements</h3>

<ol>
  <li><a href="https://docs.oracle.com/en/java/javase/21/">Java 21 or greater</a></li>
  <li>A build system that supports running the Java compiler annotation processor</li>
</ol>

The only module needed during runtime is  
<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/module-summary.html">
  <code>java.base</code>
</a>

<h3 id="limitations">Limitations</h3>

Currently Rainbow Gum does not provide support for:

<ul>
  <li>External config - by design you will need to bring your own configuration lib or just use env/system properties.</li>
  <li>Rolling of log files without external tool - there is support for rolling without losing events using external tool such as logrotate.</li>
  <li><a href="https://www.slf4j.org/api/org/slf4j/Marker.html" title="class or interface in org.slf4j" class="external-link">SLF4J Marker</a> support -  libraries and application rarely use it compared to MDC. </li>
 </ul>

 If any of these limitations (or others not listed) are a show stopper please let us know by filing an issue.
 Particularly Markers. If you are using Markers we would like to hear from you.

<h2 id="how_it_works">How it works</h2>

Most users will use Rainbow Gum through a logging facade such as SLF4J and the only interaction with
Rainbow Gum is configuration of output and formatting. Rainbow Gum provides three ways to configure
out of the box:

<ul>
  <li>Programmatic Java configuration using builders.</li>
  <li>Simple String key/value properties often derived from System properties / env variables</li>
  <li>Dependency driven configuration where including a jar as dependency changes behavior automatically</li>
</ul>

In practice many will use a mixture of all three styles. Rainbow Gum uses the Service Loader to load "default" configurations. 
Other than logger levels most configuration is simply choosing which jars to be included at runtime and providing some
simple properties.


<h2 id="architecture">Architecture</h2>

Rainbow Gum's design has many superficial similarities to Logback, Log4j2, and Reload4j in that
there are Appenders and Encoders as well as how log levels are inherited but most of Rainbow Gum's design
is <em>very different</em>!

<p>
  The key difference in Rainbow Gum is that once configured and initialized the logging system is locked in and
  cannot be changed. Certain parts of the system can be changed at runtime but require opt-in which includes changing
  levels of logger names.
</p>
<p>
  Another major difference is that Rainbow Gum is highly modularized, immutable and componentized. In other frameworks
  OOP inheritance is heavily abused and riddled with state management. Furthermore there are components that
  have too much responsibility which is the case with Appenders in Logback or "Managers" in Log4j2.
  Furthermore Rainbow Gum <strong>uses zero reflection</strong> other than the Service Loader and follows the builder pattern
  extensively to separate configuration from immutable runtime components. Almost all components have
  a builder to programmatically configure and the builders can take flat string key values as configuration. 
  The other logging frameworks use an enormous amount of reflection which slows initialization time.
  <em>(While the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/ServiceLoader.html" title="class or interface in java.util" class="external-link"><code>ServiceLoader</code></a> is technically reflection it is GraalVM native friendly and
    is the preferred way for pluggable components in modern JDKs.)
  </em>
</p>
<p>
  The results of the above choices make Rainbow Gum far lighter than logback, log4j2, and reload4j particularly
  in initialization time as well as security surface area.
</p>

<strong>The key components expressed in the flow of log events is as follows:</strong>
<ol>
<li>Logging Facade (SLF4J)</li>
<li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/RainbowGum.html" title="interface in io.jstach.rainbowgum"><code>RainbowGum</code></a></li>
<li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogRouter.html" title="interface in io.jstach.rainbowgum"><code>LogRouter</code></a></li>
<li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogPublisher.html" title="interface in io.jstach.rainbowgum"><code>LogPublisher</code></a></li>
<li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogAppender.html" title="interface in io.jstach.rainbowgum"><code>LogAppender</code></a></li>
<li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogEncoder.html" title="interface in io.jstach.rainbowgum"><code>LogEncoder</code></a></li>
<li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogOutput.html" title="interface in io.jstach.rainbowgum"><code>LogOutput</code></a></li>
</ol>

In the next sections we will cover  
<a href="#config">Config</a>, 
<a href="#publishers">Publishers</a>, 
<a href="#appenders">Appenders</a>, 
<a href="#encoders">Encoders</a>,
and 
<a href="#outputs">Outputs</a>.

<p>

Roughly the hiearchy (through composition) of components is: 

<ol>
  <li>Routes have a single publisher a level resolver and a list of appenders.</li>
  <li>Publishers <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogPublisher.PublisherFactory.html" title="interface in io.jstach.rainbowgum">are given the list of appenders</a> from the route on start.</li>
  <li>Appenders have a single encoder and output.</li>
</ol>

For most <a href="#level_resolvers">level resolving</a>, <a href="#formatters">formatters</a> (which are simplified encoders),
and <a href="outputs">Outputs</a> are the main points of interest in customizing and configuring.

<h2 id="config">Config</h2>

A defining characteristic of Rainbow Gum is that it does not have a special configuration format
like Logback, Log4j2, and Reload4j (all three use XML as the default). The expectation
is that for simple configuration <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html" title="interface in io.jstach.rainbowgum">simple properties interface</a> analogous to 
<code>Function&lt;String,String&gt;</code> is good enough. For more complicated configuration
programmatic configuration using the <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogBuilder.html" title="interface in io.jstach.rainbowgum">builders</a> and service loader should be used.
<p>
  For implementers of plugins <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogConfig.html" title="interface in io.jstach.rainbowgum"><code>LogConfig</code></a> allows registering of services
  and plugins (it also contains the global <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html" title="interface in io.jstach.rainbowgum"><code>LogProperties</code></a> ) however
  most users will not need to know about it. For those coming from Logback
  <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogConfig.html" title="interface in io.jstach.rainbowgum"><code>LogConfig</code></a> is analogous to what Logback calls "Context".
</p>

<h3 id="config_properties">Properties based</h3>

Rainbow Gum out of the box uses System properties for <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html" title="interface in io.jstach.rainbowgum"><code>LogProperties</code></a>
but an optional module <a href="io.jstach.rainbowgum.avaje/module-summary.html"><code>io.jstach.rainbowgum.avaje</code></a> will allow using <a href="https://avaje.io/config/">Avaje Config</a>
as the properties provider. Other configuration systems will be added in the future but an 
important requirement is that these systems do not do any logging or if they do allow it to be
turned off, intercepted or blocked.

<strong>
  IMPORTANT: Rainbow Gum core does not do any interpolation of property values!
  That is the responsibility of the <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html" title="interface in io.jstach.rainbowgum"><code>LogProperties</code></a>
  backing implementation and the values retrieved should already be interpolated.
</strong>
<p>
  <strong>NOTE:</strong>
  <em>
    Throughout the documentation <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Properties.html" title="class or interface in java.util" class="external-link"><code>Properties</code></a> and <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/net/URI.html" title="class or interface in java.net" class="external-link"><code>URI</code></a> syntax is used to express
    configurable properties but it is a not a requirement and 
    your configuration system may have a different format like YAML or JSON.
  </em>
</p>

<p>
A listing of property patterns that are used out of the box is discussed in <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html" title="interface in io.jstach.rainbowgum"><code>LogProperties</code></a>.

A general pattern is:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.{componentType}.{name}.{subComponent}=URI
logging.{subComponent}.{name}.{propertyName}=someStringThatIsConverted
</code></pre>
</div>


An interpolated key (note key not value) example might be:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.appender.example.encoder=gelf
logging.encoder.example.prettyPrint=true
</code></pre>
</div>


<em>
  The astute might notice that "gelf" does not look like a URI.
  It is but URIs missing schemes like the above get normalized so
  that the path is used as the scheme.
  Thus <code>gelf</code> is actually <code>gelf:///</code>
</em>

Because the first property is a URI one can do:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.appender.example.encoder=gelf:///?prettyPrint=true
</code></pre>
</div>


URIs play an important part for component provision as the  <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/net/URI.html#getScheme()" title="class or interface in java.net" class="external-link"><code>URI scheme</code></a>
is used for plugin lookup as well as single line configuration. This follows  
<a href="https://12factor.net/">12 factor</a> recommendation of resources and configuration.

</p>

<h4 id="config_plural">Plural keys for enabling/disabling</h4>

Because Rainbow Gum's property config model is a lookup of key to value 
and not a Map like collection special plural keys are used to indicate what is activated. 
These keys canonical end in <code>"s"</code> and are comma separated.

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.appenders=appender1,appender2 # appenders that are enabled.
logging.appender1.encoder=...
logging.appender2.output=...
logging.appender3.output=....
</code></pre>
</div>


In the above the configuration of <code>appender3</code> will not be used
and will not produce a configuration error if incorrect. This pattern
allows large groups of configuration to be turned on or off similar to
profiles in other systems.

<h3 id="config_builder">Builder based</h3>

Rainbow Gum can be configured programmatically through <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogBuilder.html" title="interface in io.jstach.rainbowgum">builders</a>. 
The builders normally will ignore whatever properties (key values) are set externally but most builders can be
configured by properties through 
<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogBuilder.html#fromProperties(io.jstach.rainbowgum.LogProperties)"><code>LogBuilder.fromProperties(io.jstach.rainbowgum.LogProperties)</code></a>
and thus a combination of properties and builders can be used.


<h3 id="config_change">Config Change during runtime</h3>

While most of the logging components in Rainbow Gum are immutable and cannot be changed during runtime there are some
exceptions including custom components.
<p>
  A supporting configuration system (a LogProperties provider) can notify that there has been a change
  by using the <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogConfig.html#changePublisher()">Change Publisher</a>.
  This is how level resolving changes can be published.
</p>
<p>
  Config change is by default off even on supporting configuration systems and can only be enabled by setting 
  <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html#GLOBAL_CHANGE_PROPERTY">"logging.global.change"</a> to true.
</p>

<h2 id="router">Router</h2>

A Router has a <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LevelResolver.html" title="interface in io.jstach.rainbowgum"><code>LevelResolver</code></a>, appenders and a <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogPublisher.html" title="interface in io.jstach.rainbowgum">Publisher</a>.
A Level Resolver takes a logger name and produces a <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/System.Logger.Level.html" title="class or interface in java.lang" class="external-link"><code>level</code></a>.
The logging facade implementation then decides based on the level whether or not to construct an event.
It then passes the event to the router which in turn uses the publisher to schedule the event.

For those familiar with other logging frameworks 
<strong>Rainbow Gum has no actual concept of named "Loggers"</strong> but a route from a router is the closest analog.

<p>
  When configuring routers you are configuring
  <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LevelResolver.html" title="interface in io.jstach.rainbowgum"><code>Level Resolvers</code></a> which are logger names to levels,
  which publisher to use and which appenders should be associated with the publisher. 
  We call this configuration a <em>"route"</em>. As discussed later on
  a publisher has appenders and appenders have outputs thus 
  an important consequnce of this is if you want outputs to have different level thresholds
  (e.g. a debug.log and an error.log) you will need multiple routes. 
</p>

Example configuring router with properties using <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html#ROUTE_PREFIX">"logging.route.{name}."</a>
with name set to "<code>example</code>".

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.routes=example
logging.route.example.appenders=appender1,appender2
logging.route.example.publisher=async
logging.route.example.level.com.mycompany=DEBUG
</code></pre>
</div>


If <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html#ROUTES_PROPERTY">"logging.routes"</a> is not set the route
name is assumed to be <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogRouter.Router.html#DEFAULT_ROUTER_NAME">"default"</a>.
Notice that routes can contain their own level configuration and thus a route is a way
to group appenders with the same level resolving.


<h3 id="level_resolvers">Level Resolvers</h3>

As mentioned previously routers have a level resolver. A level resolver simply resolves
the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/System.Logger.Level.html" title="class or interface in java.lang" class="external-link">level</a> (an enum) from a logger name (String).
Because of <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LevelResolver.html" title="interface in io.jstach.rainbowgum"><code>LevelResolver</code></a> functional interface we can chain them
with <em>fallbacks</em>. An important fallback level resolver that almost all routers use
is the global level resolver. These levels can be configured with 
<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html" title="interface in io.jstach.rainbowgum"><code>properties</code></a> where logger names prefixed with 
<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html#LEVEL_PREFIX">"logging.level"</a> as the key and the level as the value.
Below is an example:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.level.com.mycompany.stuff=DEBUG  # Descedant of "com.mycompany"
logging.level.com.mycompany=INFO         # Ancestor to "com.mycompany.stuff"
logging.level=ERROR
</code></pre>
</div>


<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LevelResolver.html#parseLevel(java.lang.String)">Parsing of levels from property values</a> allows SLF4J, JUL, and System.Logger format 
and case is ignored. However the logger name is case sensitive.

<p>
Although not required most level resolvers including the global follow an inheritance or prefix model where 
<code>com.mycompany.stuff.foo</code> will resolve to <code>DEBUG</code>
and <code>com.mycompany.bar</code> will resolve to <code>INFO</code>
and anything not prefixed with <code>com.mycompany</code> will resolve to <code>ERROR</code>.
An analog is to think of the "<code>.</code>" as directory path separators like in filesystems
and resolution happens by going up the directories.
This behavior is stated more formally in 
<a href="https://logback.qos.ch/manual/architecture.html#effectiveLevel">Logback's Effective Level</a>
which is what Rainbow Gum follows as well.
</p>

<p>
  An important consideration is that Rainbow Gum
  <strong>
    by default assumes Level Resolvers are cached or static and will never change.
  </strong>
  This is a critical feature of Rainbow Gum as it <em>allows facade loggers like in SLF4J to be 
  lower overhead than almost all other logging frameworks!</em>
  That being said RainbowGum allows levels to be changed if the backing configuration framework
  supports reloading and the logger name is allowed to be changed.
</p>

Below is an example of configuring to allow <em>"changing" loggers</em>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.global.change=true          # this is required to turn on level changing.
logging.change.com.mycompany=level  # only logger names starting with com.mycompany can have their levels changed.
</code></pre>
</div>


<h4 id="level_groups">Level Groups</h4>

Rainbow Gum out of the box supports
<a href="https://docs.spring.io/spring-boot/3.3.2/reference/features/logging.html#features.logging.log-groups"> 
          Spring Boot like Log Groups
</a>. 

However unlike Spring Boot groups are not enabled unless 
<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html#GROUPS_PROPERTY">"logging.groups"</a> contains the group.
(<em>this is largely because Spring Boots configuration model is like a Map and Rainbow Gums a Function.</em>)

<p>
Furthermore group levels but not group definitons can be assigned on the router itself.
Using Spring Boots example:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.groups=tomcat    # This is required otherwise the tomcat group will not be resolved
logging.group.tomcat=org.apache.catalina,org.apache.coyote,org.apache.tomcat
logging.level.tomcat=trace
logging.route.myroute.level.tomcat=info
</code></pre>
</div>


In the above <code>org.apache.catalina</code>, <code>org.apache.coyote</code>, and <code>org.apache.tomcat</code>
and their descedants
will resolve to <code>INFO</code> for "<code>myroute</code>" but <code>TRACE</code> for other routes.
Note that just like logger names groups are case sensitive.


<h4 id="Additivity">Additivity</h4>

Those familiar with Logback and Log4j2/1 "additivity" may wonder how that is achieved.
Additivity is associated with a logger name in those frameworks and means that the logger level
settings will apply to other appenders associated with logger (name) and its ancestors. If false the
settings only apply to the associated appenders at that logger and descendants.
<p>
In rainbowgum the configuration including logger name to level is done on the route 
and rainbowgum allows multiple appenders on a route and multiple routes. 
</p>

For example let us assume we want logger name <code>com.mycompany</code> (and descendants)
at 
<code>DEBUG</code> or greater to go to a file called <code>mycompany.log</code> and 
<code>WARN</code> for console <code>com.mycompany</code> (and everything else).
In Logback and others this is achieved by setting the appenders 
on <code>com.mycompany</code> and <code>additivity=false</code> but in rainbowgum this is done
by configuring separate routes:


<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.level=INFO
logging.routes=console,mycompany
logging.route.mycompany.appenders=mycompany
logging.route.mycompany.level.com.mycompany=DEBUG
logging.route.console.level=WARN
logging.route.console.appenders=console
logging.appender.mycompany.output=file:///./mycompany.log
logging.appender.console.output=stdout
</code></pre>
</div>


In the above the route <em>"console"</em> will output log entries that
will only have <code>WARN</code> or greater (<code>ERROR</code>)
to  <code>stdout</code> (terminal/console output). 
The route my <em>"mycompany"</em> will log <code>DEBUG</code> and greater but less than or equal
of <code>INFO</code> for
<code>com.mycompany</code> (and descedants like <code>com.mycompany.something</code>)
to the file <code>mycompany.log</code>.

<p>
IF we only want <code>mycompany.log</code> to have <code>com.mycompany</code> and descendants logger name entries
with <code>DEBUG</code> or greater than we turn off all other logger names. 
To do this we add to the above configuration:
</p>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.route.mycompany.level=OFF
</code></pre>
</div>


Even more sophisticated level resolution can be done programmatically with builder based configuration and custom
Level Resolvers.

<h3 id="caller_info">Caller Information</h3>

Somewhat related to level resolvers and config change is how to enable <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogEvent.html#callerOrNull()">caller info</a>.
<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogEvent.Caller.html" title="interface in io.jstach.rainbowgum"><code>LogEvent.Caller</code></a> has stack trace like information on where the logging call was made.
It is incredibly slow so like changing loggers it must be enabled and you can enable it with logger name inheritance
so not all loggers will be slow.

Below is an example of configuring to allow <em>"changing" loggers with <strong>caller info</strong></em>:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.global.change=true               # this is required to turn on level changing.
logging.change.com.mycompany=caller      # only logger names starting with com.mycompany will have caller info
</code></pre>
</div>


Caller info can be disabled dynamically with supporting configuration systems just like level changing.

Note that <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html#CHANGE_PREFIX">"logging.change"</a> is a comma separated list of 
<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogConfig.ChangePublisher.ChangeType.html" title="enum class in io.jstach.rainbowgum"><code>LogConfig.ChangePublisher.ChangeType</code></a> however caller info will automatically allow
the logger to change levels as well.

<h2 id="publishers">Publishers</h2>

A <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogPublisher.html" title="interface in io.jstach.rainbowgum"><code>LogPublisher</code></a> schedules delivery of a <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogEvent.html" title="interface in io.jstach.rainbowgum"><code>LogEvent</code></a> to a group of 
Appenders. Publishers come in two types:

<ol>
  <li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogPublisher.SyncLogPublisher.html" title="interface in io.jstach.rainbowgum">synchronous</a> - the default</li>
  <li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogPublisher.AsyncLogPublisher.html" title="interface in io.jstach.rainbowgum">asynchronous</a></li> 
</ol> 

An appender should only
belong to one publisher. In other logging frameworks like Logback and Reload4J this responsibility is handled
by an Appender but Rainbow Gum separates this responsibility out.
<p>
An example configuring a route named "example" to use the default async publisher:
</p>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.route.example.publisher=async
logging.publisher.example.bufferSize=1024
</code></pre>
</div>


Using an async publisher is a complicated topic with many caveats one of them being what to do if
the buffer is full. Rainbow Gum's default async publisher is a simple blocking queue implementation
that has a single consumer thread and will block producing threads if the queue is full.
The consumer thread simple iterates over the appenders pushing to each one. This loosely follows the
single writer principle. In the future
particularly with virtual threads more sophisticated async publishers might be offered
that might fan-out and other exotic strategies.
<p>
  <strong>NOTE:</strong> If you want some appenders to be async and others sync you just create multiple routes. 
</p>

Rainbow Gum has an experimental async publisher that uses the LMAX Disruptor ringbuffer: <a href="io.jstach.rainbowgum.disruptor/module-summary.html"><code>io.jstach.rainbowgum.disruptor</code></a>.
If the jar is found on start it will replace the default async publisher.

<h2 id="appenders">Appenders</h2>

An <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogAppender.html" title="interface in io.jstach.rainbowgum">appender</a> contains an <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogEncoder.html" title="interface in io.jstach.rainbowgum">Encoder</a> 
and an <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogOutput.html" title="interface in io.jstach.rainbowgum"><code>Output</code></a>.
Unlike other logging frameworks  there are no custom Appenders as most of the work is done by the encoder and output.
That is an appender can be mostly thought of as a tuple of encoder and output as well as it supervises both. 
<p>
Appenders are associated to the previously mentioned route. Like previously mentioned when a route is not given a
name it is automatically named <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogRouter.Router.html#DEFAULT_ROUTER_NAME">"default"</a>.
Thus to register appenders to the default route one can use:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.appenders=myappender
logging.appender.myappender.flags=reuse_buffer # an example config of appender
</code></pre>
</div>


If the route is named say "example" then configuration of the appenders can be done like:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.route.example.appenders=myappender
logging.appender.myappender.flags=reuse_buffer # an example config of appender
</code></pre>
</div>


<h3 id="appender_config">Appender Configuration</h3>

Appenders can be configured either programmatically through the <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogAppender.Builder.html" title="class in io.jstach.rainbowgum"><code>builder</code></a>
or through properties.

<dl class="notes">
  <dt><a href="#outputs">Output</a></dt>
  <dd><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogAppender.html#APPENDER_OUTPUT_PROPERTY">"logging.appender.{name}.output"</a> = URI</dd>
  <dt><a href="#encoder">Encoder</a></dt>
  <dd><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogAppender.html#APPENDER_ENCODER_PROPERTY">"logging.appender.{name}.encoder"</a> = URI</dd>
  <dt><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogAppender.AppenderFlag.html" title="enum class in io.jstach.rainbowgum">Flags</a></dt>
  <dd><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogAppender.html#APPENDER_FLAGS_PROPERTY">"logging.appender.{name}.flags"</a> = List of <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogAppender.AppenderFlag.html" title="enum class in io.jstach.rainbowgum"><code>LogAppender.AppenderFlag</code></a></dd>
</dl>

An important Appender Flag is <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogAppender.AppenderFlag.html#IMMEDIATE_FLUSH"><code>LogAppender.AppenderFlag.IMMEDIATE_FLUSH</code></a> which
will tell the output to flush after each event. This flag is disabled by default for performance reasons
however if one would like to follow <a href="https://12factor.net/logs">12 Factors requirements of events written unbuffered</a> 
synchronously this flag should be used.

<h3 id="appender_reentry">Appender Reentry Protection</h3>

A problem that can occur in any logging framework is if an output, appender, or encoder does logging which if
synchronous will usually cause a stackoverflow and if asynchronous an infinite stream of events. Let us create
a hypothetical example where we have an Output that uses a message queue client. The message queue client uses
SLF4J for logging. If an event is sent that causes the message queue client to log an event and that event is not discarded
and the output client then logs the event it created you get reentry in a synchronous publisher. 
With asynchronous it is far worse as there will be less immediate evidence that something is broken and instead a never ending supply of log entries.

<p>

Some logging frameworks like <a href="https://logback.qos.ch/manual/appenders.html#AppenderBase">logback provide reentry protection</a>
usually through threadlocals but one must understand this only works if logging is synchronous (synchronous publisher), hurts performance, 
and is just a misleading bandaid over a potential serious problem if the events are being dropped (which logback does by default).
<strong>That is why Rainbow Gum does not provide reentry protection unless requested!</strong> 
However the flags <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogAppender.AppenderFlag.html#REENTRY_DROP"><code>LogAppender.AppenderFlag.REENTRY_DROP</code></a> and <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogAppender.AppenderFlag.html#REENTRY_LOG"><code>LogAppender.AppenderFlag.REENTRY_LOG</code></a>
can be used to provide similar and arguably better protection than logback.
<p>
<strong>Overall the real solution is to fix the output so that it filters events that would cause such behavior or ideally not do any logging.</strong>

<h2 id="encoders">Encoders</h2>

Encoders encode an event into binary. Because most encoding is text based RainbowGum has the concept of 
<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogFormatter.html" title="interface in io.jstach.rainbowgum"><code>LogFormatter</code></a> which can be turned into an Encoder and is covered 
in the next section. However there are scenarios where generating bytes directly is desirable.
<p>
  Rainbow Gum JSON encoder module <a href="io.jstach.rainbowgum.json/module-summary.html"><code>io.jstach.rainbowgum.json</code></a> has efficient JSON encoders.
  <em>
    They are encoders instead of formatters (which are covered next) because writting JSON as bytes is more efficient.
  </em>
</p>
Configuring an <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html#APPENDER_ENCODER_PROPERTY">appenders encoder with properties</a>
looks something like:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">logging.appenders=myappender
logging.appender.myappender.encoder=gelf
logging.encoder.myappender.prettyPrint=true
</code></pre>
</div>


The above will use the GELF JSON encoder and configure it to pretty print.
<p>
Encoders should have a builder as well to configure programmatically
and the builders javadoc has the string properties that can configure it.
</p>

Here are some of the supported encoders (not a complete listing):

<ul>
  <li><a href="io.jstach.rainbowgum.json/io/jstach/rainbowgum/json/encoder/GelfEncoderBuilder.html" title="class in io.jstach.rainbowgum.json.encoder"><code>GelfEncoderBuilder</code></a></li>
  <li><a href="io.jstach.rainbowgum.pattern/io/jstach/rainbowgum/pattern/format/PatternEncoderBuilder.html" title="class in io.jstach.rainbowgum.pattern.format"><code>PatternEncoderBuilder</code></a></li>
</ul>


<h3 id="formatters">Formatters</h3>

Formatting of log events as textual data is so common that Rainbow Gum has special support for that with
<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogFormatter.html" title="interface in io.jstach.rainbowgum"><code>LogFormatter</code></a>. While formatters can at high-level be considered
an encoder for technical API reasons they are not. However any formatter can be converted to an
encoder with <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogEncoder.html#of(io.jstach.rainbowgum.LogFormatter)"><code>LogEncoder.of(io.jstach.rainbowgum.LogFormatter)</code></a>. 

<h4 id="pattern">Pattern Formatter</h4>

  For those coming from Logback or Log4j2 
  Rainbow Gum has an <a href="io.jstach.rainbowgum.pattern/module-summary.html">optional module</a> for 
  <a href="https://logback.qos.ch/manual/layouts.html#ClassicPatternLayout">Logback style based pattern</a> formatters. 
  This allows describing an output format using 
  <code>String.format</code> percent style syntax. Rainbow Gum implements most of the builtin Logback
  pattern keywords with far less overhead. 
  <p>
Like Logback you can even add your own pattern keywords which is covered in <a href="io.jstach.rainbowgum.pattern/module-summary.html"><code>io.jstach.rainbowgum.pattern</code></a> module.
  </p>
  <strong>The pattern module is pulled in by default with the aggregate rainbow gum dependency.</strong> 
<p>
  <strong>NOTE:</strong> <em>If you plan on using the <strong>color </strong> pattern keywords it is generally a good idea (for now) to use
    the <a href="io.jstach.rainbowgum.jansi/module-summary.html"><code>io.jstach.rainbowgum.jansi</code></a> module which is covered next.</em> Regardless ANSI escape can be
    globally disabled by setting <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html#GLOBAL_ANSI_DISABLE_PROPERTY">"logging.global.ansi.disable"</a> to
    <code>true</code> which will disable Jansi and the <em>default</em> pattern formatter from omitting ANSI escape sequences.
</p>

<h4 id="jansi">JAnsi support</h4>
<p>
  Rainbow Gum also has support for proper cross platform <a href="io.jstach.rainbowgum.jansi/module-summary.html">ANSI output with JAnsi through an optional module</a>.
  Unlike other frameworks where this is detected with reflection Rainbow Gum uses the 
  Service Loader which is GraalVM native friendly.
</p>
  <strong>Why is JAnsi desirable?</strong>
  <ul>
    <li>Support stripping ANSI characters on piping out which is desirable if you only use the console for output which
      is often the case for kubernetes and other microservices.
    </li>
    <li>
      Windows color output support.
    </li>
  </ul>
<p>
  <strong>NOTE:</strong>
  <em>
    <a href="https://openjdk.org/jeps/8307341">Future versions of the JDK may require command line arguments</a> 
    for using jars packaged with native libraries. Given that Rainbow Gum favors security
    we strongly agree with the draft JEP and are exploring other options for the future.
  </em>
</p>
Jansi can be disabled with <a href="io.jstach.rainbowgum.jansi/io/jstach/rainbowgum/jansi/JAnsiConfigurator.html#JANSI_DISABLE">"logging.jansi.disable"</a>
or <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html#GLOBAL_ANSI_DISABLE_PROPERTY">"logging.global.ansi.disable"</a> boolean properties.
<p>
  A major reason to disable Jansi is because it may <em>accidentally strip ANSI escape characters for terminals that
  do support ANSI but Jansi cannot determine they do</em>. The most notable case of this problem are IDE terminals/consoles particularly
  <a href="https://youtrack.jetbrains.com/issue/IDEA-132822"><strong>IntelliJ's</strong></a>. 
</p>

<h2 id="outputs">Outputs</h2>

<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogOutput.html" title="interface in io.jstach.rainbowgum"><code>LogOutput</code></a> do the actual work of outputting an event.

Configuring an <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html#APPENDER_OUTPUT_PROPERTY">appenders output with properties</a>
looks something like:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">  logging.appenders=myappender
  logging.appender.myappender.output=stdout
</code></pre>
</div>


One caveat with file support output via URI is if you need to output to a file in the current working directory
the URI should be prefixed with <code>./</code>.

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">  logging.appenders=myappender
  # logging.appender.myappender.output=app.log this is wrong.
  logging.appender.myappender.output=./app.log
</code></pre>
</div>


The reason is that Rainbow Gum will think <code>app.log</code> is a URI scheme if it is not prefixed.
Of course fully qualified file URI are supported as well like: <code>file:///./app.log</code>.
For Spring Boot compatibility <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogProperties.html#FILE_PROPERTY">"logging.file.name"</a> is also supported
if custom routers and appenders are not configured.

<p>
Here are some of the supported outputs (not a complete listing):
</p>

<ul>
  <li>stdout and stderr</li>
  <li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/output/FileOutputBuilder.html" title="class in io.jstach.rainbowgum.output"><code>FileOutputBuilder</code></a> with URI scheme of "file"</li>
  <li><a href="io.jstach.rainbowgum.rabbitmq/io/jstach/rainbowgum/rabbitmq/RabbitMQOutputBuilder.html" title="class in io.jstach.rainbowgum.rabbitmq"><code>RabbitMQOutputBuilder</code></a> with URI scheme of "amqp"</li>
</ul>

<h3 id="rolling">Rolling Files</h3>

Rainbow Gum currently does not support rolling of files on its own but does provide a mechanism
to safely allow external programs such as 
<a href="https://manpages.debian.org/latest/logrotate/logrotate.8.en.html">logrotate</a> to do the rolling. 
How this typically works:

<ol>
<li>External program moves the current log file. Rainbow Gum will continue to log to the same file but the file name is effectively changed.</li>
<li>Signals to the Java process with Rainbow Gum to reopen the files. This signal is usually done via HTTP or TCP socket since Java does not support Unix signals.</li>
<li>The external program then typically compresses, delete or send the log files elsewhere.</li>
</ol>


The critical thing that is happening is that Rainbow Gum closes the moved log file and then reopens the original named log file
thus releasing the moved log file descriptor allowing the external program to process it without dropped log events, contention or corruption.
<p>
(<em>The other method of rotating files without doing a move and reopen is called "copy truncate" but has the potential of losing events.
  This method avoids that problem.
</em>)
</p>
Unfortunately Rainbow Gum does not offer a way to receive the external signal as this can vary greatly across applications.
The following is an example of reopening outputs using HTTP for signaling.

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">/*
 * This method could be bound to an internal HTTP route say /log/rotate such that curl
 * http://localhost:8080/log/rotate will block and wait till all the applicable
 * outputs have reopened.
 */
@RequestMapping("/log/rotate")
@ResponseBody
public String someInternalHttpRequestHandler() {
	var gum = RainbowGum.getOrNull();
	if (gum != null) {
		List&lt;LogResponse&gt; response = gum.config() //
			.outputRegistry() //
			.reopen(); // Here is where we siginal to reopen outputs that support
						// reopening.
		return response.toString();
	}
	return "";
}
</code></pre>
</div>


Let us assume the above code is bound to <code>http://localhost:8080/log/rotate</code> and we have configured our logging like

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-properties">  logging.appenders=myappender
  logging.appender.myappender.output=/var/log/app.log
</code></pre>
</div>


We might have a logrotate script that looks like:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code>/var/log/app.log
{
  rotate 4
  weekly
  missingok
  notifempty
  compress
  delaycompress
  # we only need one call to reopen all files
  sharedscripts
  # in most cases it is best for rainbowgum recreate the file which wil happen after the postrotate
  nocreate
  postrotate
    /usr/bin/curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/log/rotate | {
      read status
      if [ "$status" -ne 200 ]; then
          logger "logrotate: Error hitting endpoint, received HTTP status $status"
      fi
    }
  endscript
}
</code></pre>
</div>


<h2 id="filter">Filtering</h2>

Like logback Rainbow Gum provides two types of filtering through functional composition:

<ol>
  <li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogRouter.Router.RouterFactory.html#of(java.util.function.Function)">router based filtering</a> 
    - similar to logbacks normal filters.</li>
  <li><a href="io.jstach.rainbowgum.slf4j/io/jstach/rainbowgum/slf4j/spi/LoggerDecoratorService.html" title="class in io.jstach.rainbowgum.slf4j.spi">SLF4J based filtering</a> 
    - similar to <a href="https://logback.qos.ch/manual/filters.html#TurboFilter">logback Turbo Filters</a></li>
</ol>

<h3 id="router_filter">Event based Filtering</h3>

Unfortunately at this time router based filtering is not configurable through properties and can only be
added using <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/RainbowGum.Builder.html" title="class in io.jstach.rainbowgum">Rainbow Gum builder</a>
and composition has to be done manually.
<p>

  An example using router based filtering:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">RainbowGum.builder(config) //
	.route(rb -&gt; {
		rb.factory(RouterFactory.of(e -&gt; {
			/*
			 * We only log DEBUG level events.
			 */
			return switch (e.level()) {
				case DEBUG -&gt; e;
				default -&gt; null;
			};
		}));
		/*
		 * If we do not set the level correctly the router will never get the
		 * event regardless of the logic of the above filtering function.
		 */
		rb.level(Level.DEBUG);
	});
</code></pre>
</div>


The above creates a custom <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogRouter.Router.html" title="interface in io.jstach.rainbowgum"><code>LogRouter.Router</code></a>
with a function. 

<em>
Event based filtering is still based on the invariants
of level resolvers not changing (unless they are configured to be dynamic) so
not all events are delivered if the level resolved does not not allow it!
</em>
A work around is to adjust the levels of the router so that it does get
all events desired and is why filtering is associated with routing.
<strong>Unfortunately this can be inefficient as the event always has to be created</strong>
so if performance matters consider using <a href="#slf4j_filter">SLF4J based filtering</a>.

</p>

<h3 id="slf4j_filter">SLF4J based filtering</h3>

<a href="io.jstach.rainbowgum.slf4j/io/jstach/rainbowgum/slf4j/spi/LoggerDecoratorService.html" title="class in io.jstach.rainbowgum.slf4j.spi">SLF4J based filtering</a> is
not simple filtering but rather decorating of the SLF4J loggers somewhat akin to Servlet filtering.
Rainbow Gum hands off its generated SLF4J logger to you and you can decorate or even disregard
it and provide your own implementation. This is extremely powerful and efficient but requires more work.
There is not really an analog in Logback or Log4j but as usual <em>with great power comes great responsibility</em>!
<p>
These filters are usually loaded with the ServiceLoader so manually using the Rainbow Gum builder is not required
like router based filtering.
</p>


<h2 id="installation">Installation</h2>

For most simply including the dependency <code>io.jstach.rainbowgum:rainbowgum</code>
is enough. That dependency will transitively pull in the most commonly used modules.
For a more minimal setup (total application size in terms of classes)
<code><a href="io.jstach.rainbowgum/module-summary.html">io.jstach.rainbowgum:rainbowgum-core</a></code>
and <code><a href="io.jstach.rainbowgum.slf4j/module-summary.html">io.jstach.rainbowgum:rainbowgum-slf4j</a></code> 
(if using SLF4J)
should be used.

<h3 id="maven">Maven</h3>

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-xml">&lt;properties&gt;
    &lt;rainbowgum.version&gt;0.7.0&lt;/rainbowgum.version&gt;
&lt;/properties&gt;
...
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.jstach.rainbowgum&lt;/groupId&gt;
        &lt;artifactId&gt;rainbowgum&lt;/artifactId&gt;
        &lt;version&gt;${rainbowgum.version}&lt;/version&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
</div>



If you plan on configuring Rainbow Gum programmatically you will need to make a module and create a
service loader registration. In that case you will want the dependency like:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-xml">&lt;properties&gt;
    &lt;rainbowgum.version&gt;0.7.0&lt;/rainbowgum.version&gt;
&lt;/properties&gt;
...
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.jstach.rainbowgum&lt;/groupId&gt;
        &lt;artifactId&gt;rainbowgum-core&lt;/artifactId&gt;
        &lt;version&gt;${rainbowgum.version}&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
</div>


<h3 id="3.2">Gradle</h3>

<pre><code class="language-kotlin">
dependencies {
    
    runtimeOnly 'io.jstach.rainbowgum:rainbowgum:0.7.0'
}
</code>
</pre>


If you plan on configuring Rainbow Gum programmatically you will need to make a module and create a
service loader registration. In that case you will want the dependency like:

<pre><code class="language-kotlin">
dependencies {
    
    implementation 'io.jstach.rainbowgum:rainbowgum-core:0.7.0'
}
</code>
</pre>

<h2 id="integration">Extensions and Integrations</h2>

<h3 id="slf4j">SLF4J 2.0</h3>

Rainbow Gum SLF4J module <a href="io.jstach.rainbowgum.slf4j/module-summary.html"><code>io.jstach.rainbowgum.slf4j</code></a> supports:
<ul>
<li><a href="https://slf4j.org/manual.html#mdc">MDC</a></li>
<li><a href="https://slf4j.org/manual.html#fluent">Fluent Logging API</a></li>
<li><a href="io.jstach.rainbowgum.slf4j/io/jstach/rainbowgum/slf4j/spi/LoggerDecoratorService.html" title="class in io.jstach.rainbowgum.slf4j.spi">Decorating loggers</a></li>
<li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogEvent.Caller.html" title="interface in io.jstach.rainbowgum">Caller Information</a></li>
</ul>
However there is currently no <a href="https://www.slf4j.org/api/org/slf4j/Marker.html" title="class or interface in org.slf4j" class="external-link"><code>Marker</code></a> support. 
<p>
Rainbow Gum supports key value pairs
in <a href="https://www.slf4j.org/api/org/slf4j/spi/LoggingEventBuilder.html" title="class or interface in org.slf4j.spi" class="external-link"><code>LoggingEventBuilder</code></a> by overlaying on top
of the current MDC at the time the event is constructed and put into the
<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogEvent.html#keyValues()"><code>events key values</code></a>.
The value parameter in 
<a href="https://www.slf4j.org/api/org/slf4j/spi/LoggingEventBuilder.html#addKeyValue(java.lang.String,java.util.function.Supplier)" title="class or interface in org.slf4j.spi" class="external-link"><code>LoggingEventBuilder.addKeyValue(String,Object)</code></a> are
converted to <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link"><code>String</code></a> immediately as only String values are
supported at this time.
<p>
Rainbow Gum SLF4J implementation is unique in that it has 
two special implementation of loggers:
<ul>
<li>Level Logger - logger based on level threshold and <em>can never change</em>!</li>
<li>Changing Logger - level and other configuration <em>can change</em>.</li>
</ul>
Other logging implementations like Logback by default use something analogous to changing loggers
which require a constant check if the level threshold has changed.
Level loggers do not need to do that check. Unless 
<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogConfig.ChangePublisher.html" title="interface in io.jstach.rainbowgum">changing loggers is turned on</a> 
by default Level Loggers are used which are close to zero cost for discarding events.

<h3 id="system_logger">java.lang.System.Logger and java.util.logging</h3>

Rainbow Gum <a href="io.jstach.rainbowgum.jdk/module-summary.html"><code>io.jstach.rainbowgum.jdk</code></a> module provides special integration and adapters for the builtin JDK logging facilities.
The impetus for this is these logging facilities can be used early in the JDK boot processes well before
logging has fully initialized. The default rainbow gum dependency has this integration as a transitive dependency.

<p>
The integration will make sure that neither the System.Logger or java.util.logging initialize
Rainbow Gum too early by queueing the events. When a Rainbow Gum initializes and 
<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/RainbowGum.html#set(io.jstach.rainbowgum.RainbowGum)">set as global</a> the events will be replayed.
If the events level are equal to <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/System.Logger.Level.html#ERROR" title="class or interface in java.lang" class="external-link"><code>System.Logger.Level.ERROR</code></a> and a normal Rainbow Gum has not been bound
the messages will be printed to <code>System.err</code>. 
The idea is something catastrophic has happened that will probably cause Rainbow Gum to never load and thus never replay the events
and you will not be able to figure out what happened otherwise.
</p>
<p>
  SLF4J does 
  <a href="https://www.slf4j.org/manual.html#jep264">provide an adapter/bridge for the System.Logger (org.slf4j:slf4j-jdk-platform-logging)</a> 
  but its use may cause Rainbow Gum to initialize
  too early. <strong>However that maybe desirable if</strong>:
</p>
  <ul>
    <li>You are sure that Rainbow Gum can initialize early</li>
    <li>Your application uses System.Logger 
      (the SLF4J adapter will initialize Rainbow Gum on System.Logger usage if using <a href="io.jstach.rainbowgum.slf4j/module-summary.html"><code>io.jstach.rainbowgum.slf4j</code></a>)
    </li>
  </ul>
  In the future Rainbow Gum may include a System.Logger provider module that does eager initialization. 
<p>
  <em>
    <strong>NOTE:</strong>
    While the JDK System.Logger is good for low level libraries that rarely log 
    it's API (and Rainbow Gum implementation) is not designed for performance.
    For applications and frameworks that do a lot of logging the SLF4J facade is the preferred choice.
  </em>
</p>

<h3 id="spring_boot">Spring Boot</h3>

Rainbow Gum provides Spring Boot 3 or greater support that is maintained by the Rainbow Gum project.

<p>
Spring Boot allows configuration through simple properties for logging that tries to be logging framework agnostic.
How this works is Spring Boot configures the logging framework from its own set of properties.
There is a shocking amount of code Spring Boot requires to do this for Logback and Log4J2
because both of those frameworks were not designed well for programmatic configuration.
</p>

<p>
<strong>Rainbow Gum key value configuration is purposely very similar and largely compatible with
  Spring Boot's</strong> <em>however</em> Spring Boot still requires special integration if you would like
to use its configuration system (for example <code>application.properties</code>). 
This is because Spring Boot uses/needs logging for initialization of its configuration system.
</p>

The recommended setup of Spring Boot with Maven is:

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-xml">  &lt;dependencies&gt;
     &lt;dependency&gt;
      &lt;groupId&gt;io.jstach.rainbowgum&lt;/groupId&gt;
      &lt;artifactId&gt;rainbowgum-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;0.7.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
      &lt;exclusions&gt;
        &lt;!--
          This is the important part as logback will be used otherwise
          regardless if rainbow gum spring boot integration is used.
        --&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
</div>


Note that if one chooses to not use <code>rainbowgum-spring-boot-starter</code> 
or <code>rainbowgum-spring-boot</code> Spring will re-initialize 
<code>java.util.logging</code> and take over it so again the integration is recommended.

<p>

See <a href="io.jstach.rainbowgum.spring.boot/module-summary.html"><code>io.jstach.rainbowgum.spring.boot</code></a>.


<h3 id="plugin_guide">Extension development guide</h3>

To a develop a custom plugin it is probably easiest to look at the other rainbow gum modules.
An important concept with extensions are the registries which allow you to register
a provider with a URI scheme.

<ol>
  <li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogPublisherRegistry.html" title="interface in io.jstach.rainbowgum"><code>LogPublisherRegistry</code></a></li>
  <li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogEncoderRegistry.html" title="interface in io.jstach.rainbowgum"><code>LogEncoderRegistry</code></a></li>
  <li><a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogOutputRegistry.html" title="interface in io.jstach.rainbowgum"><code>LogOutputRegistry</code></a></li>
</ol>
<a href="io.jstach.rainbowgum/io/jstach/rainbowgum/LogConfig.html" title="interface in io.jstach.rainbowgum"><code>LogConfig</code></a> contains all the registries
and a special generic registry: <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/ServiceRegistry.html" title="interface in io.jstach.rainbowgum"><code>ServiceRegistry</code></a>.
The service registry is allows other plugins to share components.
To access these registries at configuration time as a plugin is to implement
a <a href="io.jstach.rainbowgum/io/jstach/rainbowgum/spi/RainbowGumServiceProvider.Configurator.html" title="interface in io.jstach.rainbowgum.spi"><code>RainbowGumServiceProvider.Configurator</code></a>.

<p>
Next one should construct builders that are properties friendly to create the components
so that programmatic configuration users can use your extension. Rainbow Gum provides
an annotation processor that helps create builders
<a href="io.jstach.rainbowgum.annotation/module-summary.html"><code>io.jstach.rainbowgum.annotation</code></a>.

<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-xml">  &lt;properties&gt;
      &lt;rainbowgum.version&gt;0.7.0&lt;/rainbowgum.version&gt;
  &lt;/properties&gt;
  ...
  &lt;dependencies&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;io.jstach.rainbowgum&lt;/groupId&gt;
          &lt;artifactId&gt;rainbowgum-core&lt;/artifactId&gt;
          &lt;version&gt;${rainbowgum.version}&lt;/version&gt;
          &lt;scope&gt;compile&lt;/scope&gt;
      &lt;/dependency&gt;
      &lt;!-- This is the annotation processor --&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;io.jstach.rainbowgum&lt;/groupId&gt;
          &lt;artifactId&gt;rainbowgum-apt&lt;/artifactId&gt;
          &lt;version&gt;${rainbowgum.version}&lt;/version&gt;
          &lt;!-- the following maven config is important as the annotation processor should never be a transitive dep --&gt;
          &lt;scope&gt;provided&lt;/scope&gt;
          &lt;optional&gt;true&lt;/optional&gt;
      &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
</div>


Once the annotation processor is enabled one can create a properties aware builder with a
single static factory method annotated with <a href="io.jstach.rainbowgum.annotation/io/jstach/rainbowgum/annotation/LogConfigurable.html" title="annotation interface in io.jstach.rainbowgum.annotation"><code>LogConfigurable</code></a>.

</p>

<h2 id="FAQ">FAQ</h2>

<h3 id="faq_editdoc">There is a typo in this documentation how can I fix it?</h3>

If you would like to make corrections please
file an issue or even better fork, edit, PR this file: 
<pre><a href="https://github.com/jstachio/rainbowgum/blob/main/doc/overview.html">doc/overview.html</a></pre>

<h3 id="faq_javadoc">Where is the Javadoc?</h3>

<em>Shockingly this document is the Javadoc!</em> To be precise it is the aggregate javadoc 
<code>overview.html</code>. 

The modules javadocs should be at the bottom of this document and the search bar at the top can be
used to find documented classes.

<br/>
</div></div>
<div id="all-modules-table">
<div class="caption"><span>Modules</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Module</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color all-modules-table all-modules-table-tab1"><a href="io.jstach.rainbowgum/module-summary.html">io.jstach.rainbowgum</a></div>
<div class="col-last even-row-color all-modules-table all-modules-table-tab1">
<div class="block">Core module for RainbowGum which provides low level components for logging as well as a builder 
 for creating custom RainbowGums.</div>
</div>
<div class="col-first odd-row-color all-modules-table all-modules-table-tab1"><a href="io.jstach.rainbowgum.annotation/module-summary.html">io.jstach.rainbowgum.annotation</a></div>
<div class="col-last odd-row-color all-modules-table all-modules-table-tab1">
<div class="block">Rainbowgum Annotations used for code generation.</div>
</div>
<div class="col-first even-row-color all-modules-table all-modules-table-tab1"><a href="io.jstach.rainbowgum.avaje/module-summary.html">io.jstach.rainbowgum.avaje</a></div>
<div class="col-last even-row-color all-modules-table all-modules-table-tab1">
<div class="block">Uses <a href="https://avaje.io/config/">Avaje Config</a> for LogProperties.</div>
</div>
<div class="col-first odd-row-color all-modules-table all-modules-table-tab1"><a href="io.jstach.rainbowgum.disruptor/module-summary.html">io.jstach.rainbowgum.disruptor</a></div>
<div class="col-last odd-row-color all-modules-table all-modules-table-tab1">
<div class="block"><strong>EXPERIMENTAL</strong> Disruptor async publisher.</div>
</div>
<div class="col-first even-row-color all-modules-table all-modules-table-tab1"><a href="io.jstach.rainbowgum.jansi/module-summary.html">io.jstach.rainbowgum.jansi</a></div>
<div class="col-last even-row-color all-modules-table all-modules-table-tab1">
<div class="block">JANSI module that will install Jansi.</div>
</div>
<div class="col-first odd-row-color all-modules-table all-modules-table-tab1"><a href="io.jstach.rainbowgum.jdk/module-summary.html">io.jstach.rainbowgum.jdk</a></div>
<div class="col-last odd-row-color all-modules-table all-modules-table-tab1">
<div class="block">Rainbow Gum JDK components.</div>
</div>
<div class="col-first even-row-color all-modules-table all-modules-table-tab1"><a href="io.jstach.rainbowgum.json/module-summary.html">io.jstach.rainbowgum.json</a></div>
<div class="col-last even-row-color all-modules-table all-modules-table-tab1">
<div class="block">Provides JSON encoders.</div>
</div>
<div class="col-first odd-row-color all-modules-table all-modules-table-tab1"><a href="io.jstach.rainbowgum.pattern/module-summary.html">io.jstach.rainbowgum.pattern</a></div>
<div class="col-last odd-row-color all-modules-table all-modules-table-tab1">
<div class="block">Provides 
 <a href="https://logback.qos.ch/manual/layouts.html#ClassicPatternLayout">Logback style pattern formatters.</a>
 The URI scheme of pattern encoders is <a href="io.jstach.rainbowgum.pattern/io/jstach/rainbowgum/pattern/format/PatternEncoder.html#PATTERN_SCHEME">"pattern"</a>.</div>
</div>
<div class="col-first even-row-color all-modules-table all-modules-table-tab1"><a href="io.jstach.rainbowgum.rabbitmq/module-summary.html">io.jstach.rainbowgum.rabbitmq</a></div>
<div class="col-last even-row-color all-modules-table all-modules-table-tab1">
<div class="block">Provides RabbitMQ Rainbow Gum output.</div>
</div>
<div class="col-first odd-row-color all-modules-table all-modules-table-tab1"><a href="io.jstach.rainbowgum.slf4j/module-summary.html">io.jstach.rainbowgum.slf4j</a></div>
<div class="col-last odd-row-color all-modules-table all-modules-table-tab1">
<div class="block"><a href="https://slf4j.org">SLF4J</a> 2.0 implementation.</div>
</div>
<div class="col-first even-row-color all-modules-table all-modules-table-tab1"><a href="io.jstach.rainbowgum.spring.boot/module-summary.html">io.jstach.rainbowgum.spring.boot</a></div>
<div class="col-last even-row-color all-modules-table all-modules-table-tab1">
<div class="block">Rainbow Gum Spring Boot integration.</div>
</div>
<div class="col-first odd-row-color all-modules-table all-modules-table-tab1"><a href="io.jstach.rainbowgum.systemlogger/module-summary.html">io.jstach.rainbowgum.systemlogger</a></div>
<div class="col-last odd-row-color all-modules-table all-modules-table-tab1">
<div class="block">This module provides a partial System.Logger implementation.</div>
</div>
</div>
</div>
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small>Copyright &#169; 2024 <a href="https://jstach.io/rainbowgum">rainbowgum</a>. All rights reserved.</small></p>
</footer>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/anchor-js/anchor.min.js"></script>
<script src="resources/jstachio.js"></script>
</body>
</html>
